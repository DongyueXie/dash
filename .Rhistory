source('~/Documents/dash/R/dash.R')
source('~/Documents/dash/R/optmeth.R')
devtools::document()
source('~/Documents/dash/R/dash.R')
library(dash)
devtools::document()
library(dash)
library(singleCellRNASeqMouseDeng2014)
deng.counts <- Biobase::exprs(Deng2014MouseESC)
deng.meta_data <- Biobase::pData(Deng2014MouseESC)
deng.gene_names <- rownames(deng.counts)
comp_data <- t(deng.counts)
out <- dash(comp_data = t(deng.counts)[1:5,], optmethod = "mixEM", verbose=TRUE)
out$fitted_pi
out$posterior_weights
out$posmean[1:5,1:5]
deng.meta_data
which(deng.meta_data$cell_type == "early2cell")
comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),]
dim(comp_data)
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
verbose=TRUE)
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
bf = TRUE,
verbose=TRUE)
comp_data <- t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),]
concentration = NULL
mode = colMeans(t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),])
weight = list("center" = 10, "null" = 10, "corner" = 10)
def_positions = list("center" = Inf, "null" = 1, "corner" = 0.5)
optmethod = "mixEM"
verbose = FALSE
fdr_bound = 50
sample_weights = NULL
pi_init = NULL
control = list()
comp_data <- t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),]
concentration = NULL
mode = colMeans(t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),])
weight = list("center" = 10, "null" = 10, "corner" = 10)
def_positions = list("center" = Inf, "null" = 1, "corner" = 0.5)
optmethod = "mixEM"
verbose = FALSE
fdr_bound = 50
sample_weights = NULL
pi_init = NULL
control = list()
if(verbose){
cat("Checking inputs and processing the data \n")
}
if(is.null(mode)){
mode <- rep(1, dim(comp_data)[2])
}else{
mode <- mode/min(mode[mode!=0])
}
if(!is.null(sample_weights)){
if(length(sample_weights) != dim(comp_data)[1]){
stop("The length of the user-defined sample weights must match with number of rows
in the comp_data")
}
}
if(!is.null(pi_init)){
if(length(pi_init) != dim(comp_data)[2]){
stop("The length of the user-defined pi_init must match with number of columns
in the comp_data")
}
}
if(!is.null(mode)){
if(length(mode) != dim(comp_data)[2]){
stop("The length of the user-defined mode must match with number of columns
in the comp_data")
}
}
## add prior concentrations - adding an Inf and 1 concentration to the mix
## if not provided by the user
if(is.null(concentration)){
concentration <- c(Inf, 100, 50, 20, 10, 5, 2, 1, 0.5, 0.1)
}else{
concentration <- unique(c(def_positions$center, concentration, def_positions$null, def_positions$corner))
}
conc_mat <- t(sapply(concentration,function(x) return(x*mode)))
prior <- array(1, length(concentration))
prior[match(c(def_positions$center, def_positions$null, def_positions$corner), concentration)] <- c(weight$center, weight$null, weight$corner)
#############  define the matrix likelihoods   ###########################
if(verbose){
cat("Fitting the dash shrinkage \n")
}
matrix_log_lik <- matrix(0, dim(comp_data)[1], dim(conc_mat)[1])
for(n in 1:dim(comp_data)[1]){
for(k in 2:dim(conc_mat)[1]){
x <- comp_data[n,]
# numero <- sum(x)*beta(sum(conc_mat[k,]), sum(x))
lognumero <- log(sum(x)) - LaplacesDemon::ddirichlet(rep(1,2), alpha = c(sum(conc_mat[k,]), sum(x)), log=TRUE)
if(lognumero == -Inf | lognumero == Inf ){
matrix_log_lik[n, k] <- lognumero
}else{
index1 <- which(x > 0)
logdeno <- sum(log(x[index1]) -  sapply(1:length(index1), function(mm) return(LaplacesDemon::ddirichlet(rep(1,2), alpha = c(conc_mat[k, index1[mm]], x[index1[mm]]), log=TRUE))))
matrix_log_lik[n,k] <- lognumero - logdeno
# tmp1 <- exp(log(x[index1]) -  sapply(1:length(index1), function(mm) return(LaplacesDemon::ddirichlet(rep(1,2), alpha = c(conc_mat[k, index1[mm]], x[index1[mm]]), log=TRUE))))
#  tmp2 <- x[index1] * beta(conc_mat[k, index1], x[index1])
# deno <- prod(x[index1] * beta(conc_mat[k, index1], x[index1]))
# matrix_lik[n,k] <- numero/deno
}
}
matrix_log_lik[n,1] <- logfac(n) - sum(sapply(x, function(y) return(logfac(y)))) + sum(x*log(conc_mat[k,]/sum(conc_mat[k,])))
}
if(!bf){
matrix_lik <- exp(matrix_log_lik - max(matrix_log_lik[matrix_log_lik != Inf & matrix_log_lik != -Inf ]))
}else{
matrix_lik <- exp(matrix_log_lik - apply(matrix_log_lik, 1, function(x) return(max(x))) %*% t(rep(1, dim(matrix_log_lik)[2])))
}
bf <- TRUE
if(!bf){
matrix_lik <- exp(matrix_log_lik - max(matrix_log_lik[matrix_log_lik != Inf & matrix_log_lik != -Inf ]))
}else{
matrix_lik <- exp(matrix_log_lik - apply(matrix_log_lik, 1, function(x) return(max(x))) %*% t(rep(1, dim(matrix_log_lik)[2])))
}
matrix_lik
matrix_log_lik
logfac(n)
n
sapply(x, function(y) return(logfac(y)))
sum(sapply(x, function(y) return(logfac(y))))
x*log(conc_mat[k,]/sum(conc_mat[k,]))
conc_mat[k,]/sum(conc_mat[k,])
log(conc_mat[k,]/sum(conc_mat[k,]))
conc_mat[k,]
sum(x*log((conc_mat[k,]+1e-04)/sum(conc_mat[k,]+1e-04)))
logfac(n) - sum(sapply(x, function(y) return(logfac(y)))) + sum(x*log((conc_mat[k,]+1e-04)/sum(conc_mat[k,]+1e-04)))
matrix_log_lik <- matrix(0, dim(comp_data)[1], dim(conc_mat)[1])
for(n in 1:dim(comp_data)[1]){
for(k in 2:dim(conc_mat)[1]){
x <- comp_data[n,]
# numero <- sum(x)*beta(sum(conc_mat[k,]), sum(x))
lognumero <- log(sum(x)) - LaplacesDemon::ddirichlet(rep(1,2), alpha = c(sum(conc_mat[k,]), sum(x)), log=TRUE)
if(lognumero == -Inf | lognumero == Inf ){
matrix_log_lik[n, k] <- lognumero
}else{
index1 <- which(x > 0)
logdeno <- sum(log(x[index1]) -  sapply(1:length(index1), function(mm) return(LaplacesDemon::ddirichlet(rep(1,2), alpha = c(conc_mat[k, index1[mm]], x[index1[mm]]), log=TRUE))))
matrix_log_lik[n,k] <- lognumero - logdeno
# tmp1 <- exp(log(x[index1]) -  sapply(1:length(index1), function(mm) return(LaplacesDemon::ddirichlet(rep(1,2), alpha = c(conc_mat[k, index1[mm]], x[index1[mm]]), log=TRUE))))
#  tmp2 <- x[index1] * beta(conc_mat[k, index1], x[index1])
# deno <- prod(x[index1] * beta(conc_mat[k, index1], x[index1]))
# matrix_lik[n,k] <- numero/deno
}
}
matrix_log_lik[n,1] <- logfac(n) - sum(sapply(x, function(y) return(logfac(y)))) + sum(x*log((conc_mat[k,]+1e-04)/sum(conc_mat[k,]+1e-04)))
}
if(!bf){
matrix_lik <- exp(matrix_log_lik - max(matrix_log_lik[matrix_log_lik != Inf & matrix_log_lik != -Inf ]))
}else{
matrix_lik <- exp(matrix_log_lik - apply(matrix_log_lik, 1, function(x) return(max(x))) %*% t(rep(1, dim(matrix_log_lik)[2])))
}
############################  mixEM optimization ############################
if(optmethod == "mixEM"){
fit=do.call("mixEM",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control))
}else if (optmethod == "w_mixEM"){
fit=do.call("w_mixEM",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control, weights=sample_weights))
}else if (optmethod == "mixIP"){
fit=do.call("mixIP",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control))
}else{
message("optmethod npt provided correctly: switching to mixEM")
fit=do.call("mixEM",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control))
}
if(verbose){
cat("Preparing output from fitted model  \n")
}
ll <- list()
ll$fitted_pi <- fit$pihat
ll$concentration <- concentration
ll$prior <- prior
######################    posterior weights      #########################
pi_complete <- rep(1, dim(matrix_lik)[1]) %*% t(fit$pihat)
matrix_lik_adj <- matrix_lik*pi_complete
posterior_weights <- t(apply(matrix_lik_adj, 1, function(x) return(x/sum(x))))
ll$posterior_weights <- posterior_weights
########################    posterior means      ############################
conc_mat[conc_mat == Inf] <- 10^5
posmean_comp <- array(0, c(dim(comp_data)[1], dim(comp_data)[2], dim(conc_mat)[1]))
for(n in 1:dim(comp_data)[1]){
for(k in 1:dim(conc_mat)[1]){
temp <-  comp_data[n,]+ conc_mat[k,]
posmean_comp[n,,k] <- temp/sum(temp)
}
}
posmean <- matrix(0, dim(comp_data)[1], dim(comp_data)[2])
for(n in 1:dim(comp_data)[1]){
posmean[n,] <- posmean_comp[n,,]%*%posterior_weights[n,]
}
ll$posmean <- posmean
ll$posterior_weights
ll$posterior_weights
ll$concentration
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1)
bf = TRUE,
verbose=TRUE)
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE)
source('~/Documents/dash/R/dash.R')
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE)
out$posterior_weights
out$posmean[1:5,1:5]
out$concentration
out$prior
conc_mat[conc_mat == Inf] <- 10^5
posmean_comp <- array(0, c(dim(comp_data)[1], dim(comp_data)[2], dim(conc_mat)[1]))
for(n in 1:dim(comp_data)[1]){
for(k in 1:dim(conc_mat)[1]){
temp <-  comp_data[n,]+ conc_mat[k,]
posmean_comp[n,,k] <- temp/sum(temp)
}
}
posmean_comp
dim(posmean_comp)
posmean <- matrix(0, dim(comp_data)[1], dim(comp_data)[2])
for(n in 1:dim(comp_data)[1]){
posmean[n,] <- posmean_comp[n,,]%*%posterior_weights[n,]
}
posmean
posmean[1:5,]
posmean[1:5,1:5]
conc_mat[conc_mat == Inf] <- 10^5
posmean_comp <- array(0, c(dim(comp_data)[1], dim(comp_data)[2], dim(conc_mat)[1]))
for(n in 1:dim(comp_data)[1]){
for(k in 1:dim(conc_mat)[1]){
temp <-  comp_data[n,]+ conc_mat[k,]
posmean_comp[n,,k] <- (temp+1e-08)/sum(temp+1e-08)
}
}
posmean <- matrix(0, dim(comp_data)[1], dim(comp_data)[2])
for(n in 1:dim(comp_data)[1]){
posmean[n,] <- posmean_comp[n,,]%*%posterior_weights[n,]
}
posmean
posmean[1:5,1:5]
temp <-  comp_data[n,]+ conc_mat[k,]
temp
(temp+1e-08)/sum(temp+1e-08)
posmean_comp[1,1,]
conc_mat[conc_mat == Inf] <- 10^5
posmean_comp <- array(0, c(dim(comp_data)[1], dim(comp_data)[2], dim(conc_mat)[1]))
for(n in 1:dim(comp_data)[1]){
for(k in 1:dim(conc_mat)[1]){
temp <-  comp_data[n,]+ conc_mat[k,]
posmean_comp[n,,k] <- (temp+1e-08)/sum(temp+1e-08)
}
}
posmean_comp[1,1,]
posmean_comp[2,1,]
k <- 1
temp <-  comp_data[n,]+ conc_mat[k,]
temp
conc_mat[k,]
conc_mat <- t(sapply(concentration,function(x) return(x*mode)))
conc_mat[k,]
k
conc_mat[k,]
mode
concentration
concentration[concentration == Inf] <- 10^5
conc_mat <- t(sapply(concentration,function(x) return(x*mode)))
conc_mat[k,]
source('~/Documents/dash/R/dash.R')
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE)
source('~/Documents/dash/R/dash.R')
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE)
out$posmean
out$posmean[1:5,1:5]
out$posterior_weights
source('~/Documents/dash/R/dash.R')
source('~/Documents/dash/R/dash.R')
out <- dash(comp_data = t(deng.counts)[which(deng.meta_data$cell_type == "early2cell"),],
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE)
out$fitted_pi
out$concentration
out$posterior_weights
system.time(out <- dash(comp_data = t(deng.counts),
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE))
comp_data = t(deng.counts)
which(rowSums(comp_data) == 0)
comp_data <- t(deng.counts)
concentration = NULL
mode = colMeans(t(deng.counts))
weight = list("center" = 10, "null" = 10, "corner" = 10)
def_positions = list("center" = Inf, "null" = 1, "corner" = 0.5)
optmethod = "mixEM"
verbose = FALSE
fdr_bound = 50
sample_weights = NULL
pi_init = NULL
control = list()
bf <- TRUE
dim(comp_data)
if(verbose){
cat("Checking inputs and processing the data \n")
}
if(is.null(mode)){
mode <- rep(1, dim(comp_data)[2])
}else{
mode <- mode/min(mode[mode!=0])
}
if(!is.null(sample_weights)){
if(length(sample_weights) != dim(comp_data)[1]){
stop("The length of the user-defined sample weights must match with number of rows
in the comp_data")
}
}
if(!is.null(pi_init)){
if(length(pi_init) != dim(comp_data)[2]){
stop("The length of the user-defined pi_init must match with number of columns
in the comp_data")
}
}
if(!is.null(mode)){
if(length(mode) != dim(comp_data)[2]){
stop("The length of the user-defined mode must match with number of columns
in the comp_data")
}
}
## add prior concentrations - adding an Inf and 1 concentration to the mix
## if not provided by the user
if(is.null(concentration)){
concentration <- c(Inf, 100, 50, 20, 10, 5, 2, 1, 0.5, 0.1)
}else{
concentration <- unique(c(def_positions$center, concentration, def_positions$null, def_positions$corner))
}
conc <- concentration
conc[conc == Inf] <- 10^5
conc_mat <- t(sapply(conc,function(x) return(x*mode)))
conc_mat
conc_mat[1,]
conc <- concentration
conc[conc == Inf] <- 10^5
conc_mat <- t(sapply(conc,function(x) return(x*(mode+1e-04))))
prior <- array(1, length(concentration))
prior[match(c(def_positions$center, def_positions$null, def_positions$corner), concentration)] <- c(weight$center, weight$null, weight$corner)
#############  define the matrix likelihoods   ###########################
if(verbose){
cat("Fitting the dash shrinkage \n")
}
matrix_log_lik <- matrix(0, dim(comp_data)[1], dim(conc_mat)[1])
for(n in 1:dim(comp_data)[1]){
for(k in 2:dim(conc_mat)[1]){
x <- comp_data[n,]
# numero <- sum(x)*beta(sum(conc_mat[k,]), sum(x))
lognumero <- log(sum(x)) - LaplacesDemon::ddirichlet(rep(1,2), alpha = c(sum(conc_mat[k,]), sum(x)), log=TRUE)
if(lognumero == -Inf | lognumero == Inf ){
matrix_log_lik[n, k] <- lognumero
}else{
index1 <- which(x > 0)
logdeno <- sum(log(x[index1]) -  sapply(1:length(index1), function(mm) return(LaplacesDemon::ddirichlet(rep(1,2), alpha = c(conc_mat[k, index1[mm]], x[index1[mm]]), log=TRUE))))
matrix_log_lik[n,k] <- lognumero - logdeno
# tmp1 <- exp(log(x[index1]) -  sapply(1:length(index1), function(mm) return(LaplacesDemon::ddirichlet(rep(1,2), alpha = c(conc_mat[k, index1[mm]], x[index1[mm]]), log=TRUE))))
#  tmp2 <- x[index1] * beta(conc_mat[k, index1], x[index1])
# deno <- prod(x[index1] * beta(conc_mat[k, index1], x[index1]))
# matrix_lik[n,k] <- numero/deno
}
}
matrix_log_lik[n,1] <- logfac(n) - sum(sapply(x, function(y) return(logfac(y)))) + sum(x*log((conc_mat[k,]+1e-04)/sum(conc_mat[k,]+1e-04)))
}
if(!bf){
matrix_lik <- exp(matrix_log_lik - max(matrix_log_lik[matrix_log_lik != Inf & matrix_log_lik != -Inf ]))
}else{
matrix_lik <- exp(matrix_log_lik - apply(matrix_log_lik, 1, function(x) return(max(x))) %*% t(rep(1, dim(matrix_log_lik)[2])))
}
if(optmethod == "mixEM"){
fit=do.call("mixEM",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control))
}else if (optmethod == "w_mixEM"){
fit=do.call("w_mixEM",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control, weights=sample_weights))
}else if (optmethod == "mixIP"){
fit=do.call("mixIP",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control))
}else{
message("optmethod npt provided correctly: switching to mixEM")
fit=do.call("mixEM",args = list(matrix_lik= matrix_lik, prior=prior, pi_init=pi_init, control=control))
}
if(verbose){
cat("Preparing output from fitted model  \n")
}
ll <- list()
ll$fitted_pi <- fit$pihat
ll$concentration <- concentration
ll$prior <- prior
######################    posterior weights      #########################
pi_complete <- rep(1, dim(matrix_lik)[1]) %*% t(fit$pihat)
matrix_lik_adj <- matrix_lik*pi_complete
posterior_weights <- t(apply(matrix_lik_adj, 1, function(x) return(x/sum(x))))
ll$posterior_weights <- posterior_weights
########################    posterior means      ############################
conc_mat[conc_mat == Inf] <- 10^5
posmean_comp <- array(0, c(dim(comp_data)[1], dim(comp_data)[2], dim(conc_mat)[1]))
for(n in 1:dim(comp_data)[1]){
for(k in 1:dim(conc_mat)[1]){
temp <-  comp_data[n,]+ conc_mat[k,]
posmean_comp[n,,k] <- (temp+1e-08)/sum(temp+1e-08)
}
}
posmean <- matrix(0, dim(comp_data)[1], dim(comp_data)[2])
for(n in 1:dim(comp_data)[1]){
posmean[n,] <- posmean_comp[n,,]%*%posterior_weights[n,]
}
ll$posmean <- posmean
ll$datamean <- t(apply(comp_data, 1, function(x) return(x/sum(x))))
ll$posterior_weights
ll$posterior_weights[,10]
source('~/Documents/dash/R/dash.R')
system.time(out <- dash(comp_data = t(deng.counts),
optmethod = "mixEM",
mode = colMeans(comp_data),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE))
1679/60
out$posterior_weights
xmat <- rbind(c(5, 0, 2, 0),
c(1, 1, 0, 1),
c(100, 100, 50, 100),
c(20, 50, 100, 10),
c(10, 10, 200, 20),
c(50, 54, 58, 53),
c(1,1,1,3),
c(2, 4, 1, 1))
out <- dash(xmat, optmethod = "mixEM", verbose=TRUE, bf=TRUE)
out$datamean
out$posmean
comp_data <- t(deng.counts)
system.time(out <- dash(comp_data = t(deng.counts),
optmethod = "mixEM",
mode = colMeans(comp_data),
def_positions = list("center" = Inf, "null" = 1, "corner" = 1),
concentration = c(Inf, 100, 50, 20, 10, 5, 2, 1),
weight = list("center" = 100, "null" = 1, "corner" = 1),
bf = TRUE,
verbose=TRUE))
